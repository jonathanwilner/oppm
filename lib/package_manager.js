'use strict';

const webpack = require('webpack');
const webpackConfig = require('../webpack.config');
const fs = require('fs-extra');
const path = require('path');
const archiver = require('archiver');
const semver = require('semver');
const buildRelativeResourcePath = require('./resource_manager').buildRelativeResourcePath;

/**
 * Creates a manifest object that separates package contents into bundled and unbundled resources.
 * The returned object is passed as a parameter for <tt>bundleResources</tt>, which in turn uses
 * it to configure webpack.
 * @param {string} version The V4 version of the package we're building
 * @param {array} resources An array of resource objects generated by the resource manager
 * @returns {object} An object that lists all of the bundled and unbundled resources
 */
const generateManifest = (version, resources) => {
  const bundledResources = [];
  const unbundledResources = [];

  let canBeBundled = true;
  resources.forEach((resource) => {
    canBeBundled = !resource.bundleableV4Version || semver.satisfies(version, resource.bundleableV4Version);

    if (canBeBundled && resource.fileName.match(/\.(min\.js|js|css)$/)) {
      bundledResources.push(resource);
    } else {
      unbundledResources.push(resource);
    }
  });
  return { bundledResources, unbundledResources };
}

/**
 * Uses Webpack module bundler to concatenate all player assets which can be embedded
 * on a script file. Takes the bundleable assets listed on <tt>bundleManifest</tt> and outputs a
 * bundled build at the location defined on <tt>output</tt>.
 * Most of the bundling logic is actually contained on `webpack.config.js`.
 * @param {object} entryPath The directory where the package source files are located
 * @param {object} output An object containing the path and filename of the bundle to be generated
 * @param {object} bundleManifest An object with a list of the bundled and unbundled resources that comprise the package
 * @returns {Promise} A promise that will be resolved with an array that lists all the resources contained in the bundled package
 */
const bundleResources = (entryPath, output, bundleManifest) =>
  new Promise((resolve, reject) => {
    const options = {
      entry: bundleManifest.bundledResources.map(
        resource => path.join(entryPath, buildRelativeResourcePath(resource))
      ),
      copyIgnore: bundleManifest.bundledResources.map(
        resource => buildRelativeResourcePath(resource)
      )
    };
    const compiler = webpack(webpackConfig(entryPath, output, options));

    compiler.run((err, stats) => {
      if (err) {
        reject(new Error(`Failed to bundle package contents: ${err.message}`));
        return;
      }
      console.log('[webpack:build]', stats.toString({
        chunks: false,
        colors: true
      }));
      const packagedResources = [{
        path: '',
        fileName: output.fileName
      }].concat(bundleManifest.unbundledResources);
      resolve(packagedResources);
    });
  });

/**
 * Compresses a whole directory into a .zip file.
 * @param {string} sourcePath The source directory where the package files are located
 * @param {string} destPath The destination directory where the zip archive will be created
 * @param {string} archiveName The name of the archive file that will be created (.zip extension added by default)
 * @returns {Promise} A promise that is resolved when the operation is completed
 */
const createPackageArchive = (sourcePath, destPath, archiveName) =>
  new Promise((resolve, reject) => {
    const archive = archiver.create('zip', {});
    const fileName = `${archiveName}.zip`;
    const filePath = path.join(destPath, fileName);

    // fs.emptyDirSync(destPath); // TODO - Turn this on by default on dev environment
    const output = fs.createWriteStream(filePath);
    output.on('close', () => resolve({ fileName, path: destPath }));
    output.on('error', () =>
      reject(new Error('Failed to create .zip package. Make sure you have write permissions on the destination folder.'))
    );

    archive.pipe(output);
    archive.directory(sourcePath, archiveName);
    archive.finalize();
  });

exports.generateManifest = generateManifest;
exports.bundleResources = bundleResources;
exports.createPackageArchive = createPackageArchive;
