'use strict';

const webpack = require('webpack');
const webpackConfig = require('../webpack.config');
const fs = require('fs-extra');
const path = require('path');
const archiver = require('archiver');

/**
 * Creates a manifest file that can be used as an entry point in webpack. A require
 * statement is added for each entry of <tt>resources</tt>.
 * @param {string} destPath The destination folder on which to create the file
 * @param {string} fileName The name and extension of the manifest file to be created
 * @param {array} resources An array of resource objects generated by the resource manager
 * @returns {Promise} A promise that is resolved when the operation is completed
 */
const generateManifest = (destPath, fileName, resources) =>
  new Promise((resolve, reject) => {
    const file = fs.createWriteStream(path.join(destPath, fileName));
    file.on('close', () => resolve());
    file.on('error', err => reject(new Error(`Failed to create package manifest: ${err.message}`)));

    resources.forEach((resource) => {
      // TODO - Just testing for now
      if (resource.fileName.match(/\.json$/)) {
        file.write(`window.ooSkinJson = require('./${resource.path}/${resource.fileName}');\n`);
      }
      if (resource.fileName.match(/\.(min\.js|css)$/)) {
        file.write(`require('./${resource.path}/${resource.fileName}');\n`);
      }
    });
    file.end();
  });

/**
 * Uses Webpack module bundler to concatenate all player assets which can be embedded
 * on a script file. Takes the assets listed at <tt>entry</tt> and outputs a bundled build.
 * at the location defined on <tt>output</tt>.
 * Most of the bundling logic is actually contained on `webpack.config.js`
 * @param {object} entry An object containing the path and fileName of a manifest file with all player assets
 * @param {object} output An object containing the path and fileName of the bundle to be generated
 * @returns {Promise} A promise that is resolved when the operation is completed
 */
const bundleResources = (entry, output) =>
  new Promise((resolve, reject) => {
    const compiler = webpack(webpackConfig(entry, output));

    compiler.run((err, stats) => {
      if (err) {
        reject(new Error('webpack:build', err));
        return;
      }
      console.log('[webpack:build]', stats.toString({
        chunks: false,
        colors: true
      }));
      resolve();
    });
  });

/**
 * Compresses a whole directory into a .zip file.
 * @param {string} sourcePath The source directory where the package files are located
 * @param {string} destPath The destination directory where the zip archive will be created
 * @param {string} archiveName The name of the archive file that will be created (.zip extension added by default)
 * @returns {Promise} A promise that is resolved when the operation is completed
 */
const createPackageArchive = (sourcePath, destPath, archiveName) =>
  new Promise((resolve, reject) => {
    const archive = archiver.create('zip', {});
    const fileName = `${archiveName}.zip`;
    const filePath = path.join(destPath, fileName);

    fs.emptyDirSync(destPath);
    const output = fs.createWriteStream(filePath);
    output.on('close', () => resolve({ fileName, path: destPath }));
    output.on('error', () =>
      reject(new Error('Failed to create .zip package. Make sure you have write permissions on the destination folder.'))
    );

    archive.pipe(output);
    archive.directory(sourcePath, archiveName);
    archive.finalize();
  });

exports.generateManifest = generateManifest;
exports.bundleResources = bundleResources;
exports.createPackageArchive = createPackageArchive;
