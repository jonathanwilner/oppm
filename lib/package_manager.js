'use strict';

const webpack = require('webpack');
const webpackConfig = require('../webpack.config');
const fs = require('fs-extra');
const path = require('path');
const archiver = require('archiver');
const semver = require('semver');
const buildRelativeResourcePath = require('./resource_manager').buildRelativeResourcePath;

/**
 * Creates a manifest file that can be used as an entry point in webpack. A require
 * statement is added for each entry of <tt>resources</tt>.
 * @param {string} destPath The destination folder on which to create the file
 * @param {string} fileName The name and extension of the manifest file to be created
 * @param {string} version The V4 version of the package we're building
 * @param {array} resources An array of resource objects generated by the resource manager
 * @returns {Promise} A promise that will be resolved with an object that lists all of the bundled and unbundled resources
 */
const generateManifest = (destPath, fileName, version, resources) =>
  new Promise((resolve, reject) => {
    const bundledResources = [];
    const unbundledResources = [];

    const file = fs.createWriteStream(path.join(destPath, fileName));
    file.on('close', () => resolve({ bundledResources, unbundledResources }));
    file.on('error', err => reject(new Error(`Failed to create package manifest: ${err.message}`)));

    let canBeBundled = true;
    resources.forEach((resource) => {
      canBeBundled = !resource.bundleableV4Version || semver.satisfies(version, resource.bundleableV4Version);

      if (canBeBundled && resource.fileName.match(/\.(min\.js|js|css)$/)) {
        bundledResources.push(resource);
        file.write(`require('./${buildRelativeResourcePath(resource)}');\n`);
      } else {
        unbundledResources.push(resource);
      }
    });
    file.end();
  });

/**
 * Uses Webpack module bundler to concatenate all player assets which can be embedded
 * on a script file. Takes the assets listed at <tt>entry</tt> and outputs a bundled build.
 * at the location defined on <tt>output</tt>.
 * Most of the bundling logic is actually contained on `webpack.config.js`
 * @param {object} entry An object containing the path and fileName of a manifest file with all player assets
 * @param {object} output An object containing the path and fileName of the bundle to be generated
 * @param {object} bundleManifest An object with a list of the bundled and unbundled resources that comprise the package
 * @returns {Promise} A promise that will be resolved with an array that lists all the resources contained in the bundled package
 */
const bundleResources = (entry, output, bundleManifest) =>
  new Promise((resolve, reject) => {
    const options = {
      excludeFromCopy: bundleManifest.bundledResources.map(
        resource => buildRelativeResourcePath(resource)
      )
    };
    const compiler = webpack(webpackConfig(entry, output, options));

    compiler.run((err, stats) => {
      if (err) {
        reject(new Error(`Failed to bundle package contents: ${err.message}`));
        return;
      }
      console.log('[webpack:build]', stats.toString({
        chunks: false,
        colors: true
      }));
      const bundledResources = [{
        path: '',
        fileName: output.fileName
      }].concat(bundleManifest.unbundledResources);
      resolve(bundledResources);
    });
  });

/**
 * Compresses a whole directory into a .zip file.
 * @param {string} sourcePath The source directory where the package files are located
 * @param {string} destPath The destination directory where the zip archive will be created
 * @param {string} archiveName The name of the archive file that will be created (.zip extension added by default)
 * @returns {Promise} A promise that is resolved when the operation is completed
 */
const createPackageArchive = (sourcePath, destPath, archiveName) =>
  new Promise((resolve, reject) => {
    const archive = archiver.create('zip', {});
    const fileName = `${archiveName}.zip`;
    const filePath = path.join(destPath, fileName);

    // fs.emptyDirSync(destPath); // TODO - Turn this on by default on dev environment
    const output = fs.createWriteStream(filePath);
    output.on('close', () => resolve({ fileName, path: destPath }));
    output.on('error', () =>
      reject(new Error('Failed to create .zip package. Make sure you have write permissions on the destination folder.'))
    );

    archive.pipe(output);
    archive.directory(sourcePath, archiveName);
    archive.finalize();
  });

exports.generateManifest = generateManifest;
exports.bundleResources = bundleResources;
exports.createPackageArchive = createPackageArchive;
